// server/routes/acteurs-route.js - Version mise à jour
const express = require('express');
const router = express.Router();
const { pool } = require('../db/dbConnection');
const { v4: uuidv4 } = require('uuid');
const { 
  authenticateToken, 
  checkPermission, 
  filterByEntreprise,
  requireManagerOrConsultant
} = require('../middlewares/auth-middleware');

const bcrypt = require('bcryptjs');
const logger = require('../utils/logger');
const { body, validationResult } = require('express-validator');

// GET tous les acteurs (avec filtrage par entreprise)
router.get('/', 
  authenticateToken, 
  checkPermission('USERS', 'voir'), 
  filterByEntreprise,
  async (req, res) => {
    try {
      let query = `
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
      `;
      
      let params = [];
      
      // Filtrer par entreprise si l'utilisateur n'a pas accès global
      if (!req.user.hasGlobalAccess && req.entrepriseFilter) {
        query += ' WHERE a.id_entreprise = ?';
        params.push(req.entrepriseFilter);
      }
      
      query += ' ORDER BY a.nom_prenom';
      
      const [acteurs] = await pool.query(query, params);
      res.status(200).json(acteurs);
    } catch (error) {
      console.error('Erreur lors de la récupération des acteurs:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la récupération des acteurs' });
    }
  }
);

// GET acteur par ID (avec vérification d'accès)
router.get('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'voir'),
  async (req, res) => {
    try {
      const { id } = req.params;
      
      let query = `
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `;
      
      let params = [id];
      
      // Ajouter le filtre entreprise si nécessaire
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        query += ' AND a.id_entreprise = ?';
        params.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(query, params);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouvé ou accès non autorisé' });
      }
      
      res.status(200).json(acteurs[0]);
    } catch (error) {
      console.error('Erreur lors de la récupération de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la récupération de l\'acteur' });
    }
  }
);

// POST nouvel acteur (avec validation des permissions)
router.post('/', 
  authenticateToken, 
  checkPermission('USERS', 'editer'),
  async (req, res) => {
    try {
      const { 
        nom_prenom, 
        email,
        organisation,
        id_entreprise,
        id_role,
        anciennete_role
      } = req.body;
      
      if (!nom_prenom || !email || !id_role) {
        return res.status(400).json({ 
          message: 'Données invalides: nom_prenom, email et id_role sont requis' 
        });
      }
      
      // Vérifier que l'utilisateur peut créer un acteur dans cette entreprise
      if (!req.user.hasGlobalAccess && id_entreprise !== req.user.id_entreprise) {
        return res.status(403).json({ 
          message: 'Vous ne pouvez créer des acteurs que pour votre entreprise' 
        });
      }
      
      // Vérifier que le rôle existe
      const [roles] = await pool.query('SELECT * FROM roles WHERE id_role = ?', [id_role]);
      if (roles.length === 0) {
        return res.status(400).json({ message: 'Rôle invalide' });
      }
      
      // Vérifier que l'entreprise existe
      if (id_entreprise) {
        const [entreprises] = await pool.query('SELECT * FROM entreprises WHERE id_entreprise = ?', [id_entreprise]);
        if (entreprises.length === 0) {
          return res.status(400).json({ message: 'Entreprise invalide' });
        }
      }
      
      const id_acteur = uuidv4();
      const now = new Date();
      
      await pool.query(`
        INSERT INTO acteurs (
          id_acteur, nom_prenom, email, organisation, 
          id_entreprise, id_role, anciennete_role,
          date_creation, date_modification
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        id_acteur, 
        nom_prenom, 
        email, 
        organisation || 'Non spécifié',
        id_entreprise,
        id_role,
        anciennete_role || 0,
        now, 
        now
      ]);
      
      // Récupérer l'acteur créé avec toutes ses informations
      const [newActeur] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `, [id_acteur]);
      
      res.status(201).json(newActeur[0]);
    } catch (error) {
      console.error('Erreur lors de la création de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la création de l\'acteur' });
    }
  }
);

// PUT mettre à jour un acteur (avec validation des permissions)
router.put('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'editer'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { 
        nom_prenom, 
        email,
        organisation,
        id_entreprise,
        id_role,
        anciennete_role
      } = req.body;
      
      // Vérifier que l'acteur existe et appartient à la bonne entreprise
      let checkQuery = 'SELECT * FROM acteurs WHERE id_acteur = ?';
      let checkParams = [id];
      
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        checkQuery += ' AND id_entreprise = ?';
        checkParams.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(checkQuery, checkParams);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouvé ou accès non autorisé' });
      }
      
      // Vérifier les changements d'entreprise
      if (id_entreprise && !req.user.hasGlobalAccess && id_entreprise !== req.user.id_entreprise) {
        return res.status(403).json({ 
          message: 'Vous ne pouvez pas transférer un acteur vers une autre entreprise' 
        });
      }
      
      // Construire la requête de mise à jour
      let updateQuery = 'UPDATE acteurs SET date_modification = NOW()';
      const updateParams = [];
      
      if (nom_prenom) {
        updateQuery += ', nom_prenom = ?';
        updateParams.push(nom_prenom);
      }
      
      if (email) {
        updateQuery += ', email = ?';
        updateParams.push(email);
      }
      
      if (organisation !== undefined) {
        updateQuery += ', organisation = ?';
        updateParams.push(organisation);
      }
      
      if (id_entreprise !== undefined) {
        updateQuery += ', id_entreprise = ?';
        updateParams.push(id_entreprise);
      }
      
      if (id_role !== undefined) {
        updateQuery += ', id_role = ?';
        updateParams.push(id_role);
      }
      
      if (anciennete_role !== undefined) {
        updateQuery += ', anciennete_role = ?';
        updateParams.push(anciennete_role);
      }
      
      updateQuery += ' WHERE id_acteur = ?';
      updateParams.push(id);
      
      await pool.query(updateQuery, updateParams);
      
      // Si le rôle a changé, mettre à jour les permissions
      if (id_role !== undefined) {
        await pool.query('DELETE FROM permissions WHERE id_acteur = ?', [id]);
        
        await pool.query(`
          INSERT INTO permissions (id_permission, id_acteur, id_module, type_ressource, peut_voir, peut_editer, peut_supprimer, peut_administrer, conditions)
          SELECT 
            UUID(),
            ?,
            rp.id_module,
            CASE 
              WHEN m.nom_module = 'QUESTIONNAIRES' THEN 'QUESTIONNAIRE'
              WHEN m.nom_module = 'FORMULAIRES' THEN 'FORMULAIRE'
              WHEN m.nom_module = 'APPLICATIONS' THEN 'APPLICATION'
              ELSE 'RAPPORT'
            END as type_ressource,
            rp.peut_voir,
            rp.peut_editer,
            rp.peut_supprimer,
            rp.peut_administrer,
            JSON_OBJECT('entreprise_id', (SELECT id_entreprise FROM acteurs WHERE id_acteur = ?))
          FROM role_permissions rp
          JOIN modules m ON rp.id_module = m.id_module
          WHERE rp.id_role = ?
        `, [id, id, id_role]);
      }
      
      // Récupérer l'acteur mis à jour
      const [updatedActeurs] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `, [id]);
      
      res.status(200).json(updatedActeurs[0]);
    } catch (error) {
      console.error('Erreur lors de la mise à jour de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la mise à jour de l\'acteur' });
    }
  }
);

// DELETE supprimer un acteur (avec validation des permissions)
router.delete('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'supprimer'),
  async (req, res) => {
    try {
      const { id } = req.params;
      
      // Vérifier que l'acteur existe et appartient à la bonne entreprise
      let checkQuery = 'SELECT * FROM acteurs WHERE id_acteur = ?';
      let checkParams = [id];
      
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        checkQuery += ' AND id_entreprise = ?';
        checkParams.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(checkQuery, checkParams);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouvé ou accès non autorisé' });
      }
      
      // Empêcher la suppression de son propre compte
      if (id === req.user.id_acteur) {
        return res.status(400).json({ message: 'Vous ne pouvez pas supprimer votre propre compte' });
      }
      
      await pool.query('DELETE FROM acteurs WHERE id_acteur = ?', [id]);
      
      res.status(200).json({ message: 'Acteur supprimé avec succès' });
    } catch (error) {
      console.error('Erreur lors de la suppression de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la suppression de l\'acteur' });
    }
  }
);

// GET acteurs par entreprise
router.get('/entreprise/:entrepriseId', 
  authenticateToken, 
  checkPermission('USERS', 'voir'),
  async (req, res) => {
    try {
      const { entrepriseId } = req.params;
      
      // Vérifier l'accès à cette entreprise
      if (!req.user.hasGlobalAccess && entrepriseId !== req.user.id_entreprise) {
        return res.status(403).json({ message: 'Accès non autorisé à cette entreprise' });
      }
      
      const [acteurs] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_entreprise = ?
        ORDER BY a.nom_prenom
      `, [entrepriseId]);
      
      res.status(200).json(acteurs);
    } catch (error) {
      console.error('Erreur lors de la récupération des acteurs par entreprise:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la récupération des acteurs' });
    }
  }
);

// GET /api/acteurs/entreprise/:enterpriseId/by-role - Récupérer les acteurs par rôle
router.get('/entreprise/:enterpriseId/by-role', async (req, res) => {
  try {
    const { enterpriseId } = req.params;
    const { role } = req.query;
    
    let query = `
      SELECT a.*, r.nom_role, r.niveau_acces
      FROM acteurs a
      JOIN roles r ON a.id_role = r.id_role
      WHERE a.id_entreprise = ? AND a.is_active = 1
    `;
    
    let params = [enterpriseId];
    
    if (role) {
      query += ' AND r.nom_role = ?';
      params.push(role);
    }
    
    query += ' ORDER BY r.nom_role, a.nom_prenom';
    
    const [acteurs] = await pool.query(query, params);
    
    // Grouper par rôle pour une réponse structurée
    const acteursParRole = acteurs.reduce((acc, acteur) => {
      const roleName = acteur.nom_role;
      if (!acc[roleName]) {
        acc[roleName] = [];
      }
      acc[roleName].push(acteur);
      return acc;
    }, {});
    
    res.json({
      entreprise_id: enterpriseId,
      acteurs_par_role: acteursParRole,
      total: acteurs.length
    });
    
  } catch (error) {
    logger.error('Erreur récupération acteurs par rôle:', error);
    res.status(500).json({
      message: 'Erreur serveur lors de la récupération des acteurs'
    });
  }
});


// POST /api/acteurs/intervenant - Créer un intervenant pour une entreprise
router.post('/intervenant', [
  body('enterpriseId').isUUID().withMessage('ID entreprise invalide'),
  body('nom_prenom').isLength({ min: 2 }).withMessage('Nom et prénom requis'),
  body('email').isEmail().withMessage('Email invalide'),
  body('fonction').isLength({ min: 1 }).withMessage('Fonction requise'),
  body('mot_de_passe').optional().isLength({ min: 8 }).withMessage('Mot de passe trop court (minimum 8 caractères)')
], async (req, res) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      await connection.rollback();
      return res.status(400).json({
        message: 'Données de validation invalides',
        errors: errors.array()
      });
    }
    
    const {
      enterpriseId,
      nom_prenom,
      email,
      fonction,
      mot_de_passe = null
    } = req.body;
    
    logger.info('👥 Création intervenant:', { nom_prenom, email, entreprise: enterpriseId });
    
    // 1. Vérifier que l'entreprise existe
    const [enterprises] = await connection.query(
      'SELECT nom_entreprise FROM entreprises WHERE id_entreprise = ?',
      [enterpriseId]
    );
    
    if (enterprises.length === 0) {
      await connection.rollback();
      return res.status(404).json({
        message: 'Entreprise non trouvée'
      });
    }
    
    const nomEntreprise = enterprises[0].nom_entreprise;
    
    // 2. Vérifier que l'email n'existe pas déjà
    const [existingActor] = await connection.query(
      'SELECT id_acteur FROM acteurs WHERE email = ?',
      [email]
    );
    
    if (existingActor.length > 0) {
      await connection.rollback();
      return res.status(400).json({
        message: 'Un utilisateur avec cet email existe déjà'
      });
    }
    
    // 3. Obtenir le rôle Intervenant
    const [intervenantRoles] = await connection.query(
      'SELECT id_role FROM roles WHERE nom_role = ?',
      ['Intervenant']
    );
    
    if (intervenantRoles.length === 0) {
      // Créer le rôle Intervenant s'il n'existe pas
      const roleId = uuidv4();
      await connection.query(`
        INSERT INTO roles (
          id_role, nom_role, description, niveau_acces
        ) VALUES (?, ?, ?, ?)
      `, [
        roleId,
        'Intervenant',
        'Intervenant dans l\'évaluation de maturité - Participant aux questionnaires',
        'ENTREPRISE'
      ]);
      
      logger.info('Rôle Intervenant créé automatiquement:', roleId);
      intervenantRoleId = roleId;
    } else {
      intervenantRoleId = intervenantRoles[0].id_role;
    }
    
    // 4. Créer l'acteur intervenant
    const id_acteur = uuidv4();
    const now = new Date();
    let hashedPassword = null;
    
    if (mot_de_passe) {
      hashedPassword = await bcrypt.hash(mot_de_passe, 12);
    }
    
    await connection.query(`
      INSERT INTO acteurs (
        id_acteur, nom_prenom, email, mot_de_passe, organisation,
        id_entreprise, id_role, anciennete_role, is_active,
        date_creation, date_modification
      ) VALUES (?, ?, ?, ?, ?, ?, ?, 0, 1, ?, ?)
    `, [
      id_acteur, nom_prenom, email, hashedPassword,
      nomEntreprise, enterpriseId, intervenantRoleId, now, now
    ]);
    
    logger.info('✅ Intervenant créé:', { id_acteur, nom_prenom, email });
    
    // 5. Créer les permissions par défaut pour l'intervenant
    await createDefaultPermissions(connection, id_acteur, intervenantRoleId, enterpriseId);
    
    // 6. Commit transaction
    await connection.commit();
    
    // 7. Récupérer les données complètes de l'intervenant créé
    const [actorData] = await connection.query(`
      SELECT a.*, r.nom_role, e.nom_entreprise
      FROM acteurs a
      JOIN roles r ON a.id_role = r.id_role
      JOIN entreprises e ON a.id_entreprise = e.id_entreprise
      WHERE a.id_acteur = ?
    `, [id_acteur]);
    
    logger.info('🎉 Intervenant créé avec succès');
    
    res.status(201).json({
      message: 'Intervenant créé avec succès',
      acteur: {
        id_acteur: actorData[0].id_acteur,
        nom_prenom: actorData[0].nom_prenom,
        email: actorData[0].email,
        fonction: fonction,
        role: actorData[0].nom_role,
        id_entreprise: actorData[0].id_entreprise,
        nom_entreprise: actorData[0].nom_entreprise,
        has_password: !!hashedPassword
      }
    });
    
  } catch (error) {
    await connection.rollback();
    logger.error('❌ Erreur création intervenant:', error);
    res.status(500).json({
      message: 'Erreur serveur lors de la création de l\'intervenant',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  } finally {
    connection.release();
  }
});

// Helper function pour les permissions (à ajouter si pas déjà présente)
const createDefaultPermissions = async (connection, actorId, roleId, enterpriseId) => {
  try {
    // Récupérer le nom du rôle
    const [roleData] = await connection.query(
      'SELECT nom_role FROM roles WHERE id_role = ?',
      [roleId]
    );
    
    if (roleData.length === 0) {
      throw new Error('Rôle non trouvé');
    }
    
    const roleName = roleData[0].nom_role;
    
    // Récupérer tous les modules actifs
    const [modules] = await connection.query(
      'SELECT id_module, nom_module FROM modules WHERE actif = TRUE'
    );
    
    // Permissions par défaut selon le rôle
    const permissions = {
      'Manager': {
        default: {
          peut_voir: true,
          peut_editer: true,
          peut_supprimer: false,
          peut_administrer: true
        },
        specific: {
          'USERS': { peut_supprimer: true },
          'EVALUATIONS': { peut_supprimer: true },
          'RAPPORTS': { peut_administrer: true }
        }
      },
      'Intervenant': {
        default: {
          peut_voir: true,
          peut_editer: false,
          peut_supprimer: false,
          peut_administrer: false
        },
        specific: {
          'QUESTIONNAIRES': { peut_editer: true },
          'EVALUATIONS': { peut_editer: true },
          'PROFIL': { peut_editer: true }
        }
      }
    };
    
    const rolePermissions = permissions[roleName] || permissions['Intervenant'];
    
    // Créer les permissions pour chaque module
    for (const module of modules) {
      const modulePermissions = {
        ...rolePermissions.default,
        ...(rolePermissions.specific[module.nom_module] || {})
      };
      
      const permissionId = uuidv4();
      await connection.query(`
        INSERT INTO permissions (
          id_permission, id_acteur, id_module, type_ressource,
          peut_voir, peut_editer, peut_supprimer, peut_administrer,
          conditions, date_creation
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
      `, [
        permissionId,
        actorId,
        module.id_module,
        'GENERAL',
        modulePermissions.peut_voir,
        modulePermissions.peut_editer,
        modulePermissions.peut_supprimer,
        modulePermissions.peut_administrer,
        JSON.stringify({ entreprise_id: enterpriseId })
      ]);
    }
    
    logger.info(`Permissions ${roleName} créées pour l'acteur ${actorId}`);
    
  } catch (error) {
    logger.warn('Erreur lors de la création des permissions (non bloquant):', error.message);
  }
};

module.exports = router;