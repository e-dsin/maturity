// server/routes/acteurs-route.js - Version mise √† jour
const express = require('express');
const router = express.Router();
const { pool } = require('../db/dbConnection');
const { v4: uuidv4 } = require('uuid');
const { 
  authenticateToken, 
  checkPermission, 
  filterByEntreprise,
  requireManagerOrConsultant
} = require('../middlewares/auth-middleware');

const bcrypt = require('bcryptjs');
const logger = require('../utils/logger');
const { body, validationResult } = require('express-validator');

// GET tous les acteurs (avec filtrage par entreprise)
router.get('/', 
  authenticateToken, 
  checkPermission('USERS', 'voir'), 
  filterByEntreprise,
  async (req, res) => {
    try {
      let query = `
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
      `;
      
      let params = [];
      
      // Filtrer par entreprise si l'utilisateur n'a pas acc√®s global
      if (!req.user.hasGlobalAccess && req.entrepriseFilter) {
        query += ' WHERE a.id_entreprise = ?';
        params.push(req.entrepriseFilter);
      }
      
      query += ' ORDER BY a.nom_prenom';
      
      const [acteurs] = await pool.query(query, params);
      res.status(200).json(acteurs);
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des acteurs:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la r√©cup√©ration des acteurs' });
    }
  }
);

// GET acteur par ID (avec v√©rification d'acc√®s)
router.get('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'voir'),
  async (req, res) => {
    try {
      const { id } = req.params;
      
      let query = `
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `;
      
      let params = [id];
      
      // Ajouter le filtre entreprise si n√©cessaire
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        query += ' AND a.id_entreprise = ?';
        params.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(query, params);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouv√© ou acc√®s non autoris√©' });
      }
      
      res.status(200).json(acteurs[0]);
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la r√©cup√©ration de l\'acteur' });
    }
  }
);

// POST nouvel acteur (avec validation des permissions)
router.post('/', 
  authenticateToken, 
  checkPermission('USERS', 'editer'),
  async (req, res) => {
    try {
      const { 
        nom_prenom, 
        email,
        organisation,
        id_entreprise,
        id_role,
        anciennete_role
      } = req.body;
      
      if (!nom_prenom || !email || !id_role) {
        return res.status(400).json({ 
          message: 'Donn√©es invalides: nom_prenom, email et id_role sont requis' 
        });
      }
      
      // V√©rifier que l'utilisateur peut cr√©er un acteur dans cette entreprise
      if (!req.user.hasGlobalAccess && id_entreprise !== req.user.id_entreprise) {
        return res.status(403).json({ 
          message: 'Vous ne pouvez cr√©er des acteurs que pour votre entreprise' 
        });
      }
      
      // V√©rifier que le r√¥le existe
      const [roles] = await pool.query('SELECT * FROM roles WHERE id_role = ?', [id_role]);
      if (roles.length === 0) {
        return res.status(400).json({ message: 'R√¥le invalide' });
      }
      
      // V√©rifier que l'entreprise existe
      if (id_entreprise) {
        const [entreprises] = await pool.query('SELECT * FROM entreprises WHERE id_entreprise = ?', [id_entreprise]);
        if (entreprises.length === 0) {
          return res.status(400).json({ message: 'Entreprise invalide' });
        }
      }
      
      const id_acteur = uuidv4();
      const now = new Date();
      
      await pool.query(`
        INSERT INTO acteurs (
          id_acteur, nom_prenom, email, organisation, 
          id_entreprise, id_role, anciennete_role,
          date_creation, date_modification
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        id_acteur, 
        nom_prenom, 
        email, 
        organisation || 'Non sp√©cifi√©',
        id_entreprise,
        id_role,
        anciennete_role || 0,
        now, 
        now
      ]);
      
      // R√©cup√©rer l'acteur cr√©√© avec toutes ses informations
      const [newActeur] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `, [id_acteur]);
      
      res.status(201).json(newActeur[0]);
    } catch (error) {
      console.error('Erreur lors de la cr√©ation de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la cr√©ation de l\'acteur' });
    }
  }
);

// PUT mettre √† jour un acteur (avec validation des permissions)
router.put('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'editer'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { 
        nom_prenom, 
        email,
        organisation,
        id_entreprise,
        id_role,
        anciennete_role
      } = req.body;
      
      // V√©rifier que l'acteur existe et appartient √† la bonne entreprise
      let checkQuery = 'SELECT * FROM acteurs WHERE id_acteur = ?';
      let checkParams = [id];
      
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        checkQuery += ' AND id_entreprise = ?';
        checkParams.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(checkQuery, checkParams);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouv√© ou acc√®s non autoris√©' });
      }
      
      // V√©rifier les changements d'entreprise
      if (id_entreprise && !req.user.hasGlobalAccess && id_entreprise !== req.user.id_entreprise) {
        return res.status(403).json({ 
          message: 'Vous ne pouvez pas transf√©rer un acteur vers une autre entreprise' 
        });
      }
      
      // Construire la requ√™te de mise √† jour
      let updateQuery = 'UPDATE acteurs SET date_modification = NOW()';
      const updateParams = [];
      
      if (nom_prenom) {
        updateQuery += ', nom_prenom = ?';
        updateParams.push(nom_prenom);
      }
      
      if (email) {
        updateQuery += ', email = ?';
        updateParams.push(email);
      }
      
      if (organisation !== undefined) {
        updateQuery += ', organisation = ?';
        updateParams.push(organisation);
      }
      
      if (id_entreprise !== undefined) {
        updateQuery += ', id_entreprise = ?';
        updateParams.push(id_entreprise);
      }
      
      if (id_role !== undefined) {
        updateQuery += ', id_role = ?';
        updateParams.push(id_role);
      }
      
      if (anciennete_role !== undefined) {
        updateQuery += ', anciennete_role = ?';
        updateParams.push(anciennete_role);
      }
      
      updateQuery += ' WHERE id_acteur = ?';
      updateParams.push(id);
      
      await pool.query(updateQuery, updateParams);
      
      // Si le r√¥le a chang√©, mettre √† jour les permissions
      if (id_role !== undefined) {
        await pool.query('DELETE FROM permissions WHERE id_acteur = ?', [id]);
        
        await pool.query(`
          INSERT INTO permissions (id_permission, id_acteur, id_module, type_ressource, peut_voir, peut_editer, peut_supprimer, peut_administrer, conditions)
          SELECT 
            UUID(),
            ?,
            rp.id_module,
            CASE 
              WHEN m.nom_module = 'QUESTIONNAIRES' THEN 'QUESTIONNAIRE'
              WHEN m.nom_module = 'FORMULAIRES' THEN 'FORMULAIRE'
              WHEN m.nom_module = 'APPLICATIONS' THEN 'APPLICATION'
              ELSE 'RAPPORT'
            END as type_ressource,
            rp.peut_voir,
            rp.peut_editer,
            rp.peut_supprimer,
            rp.peut_administrer,
            JSON_OBJECT('entreprise_id', (SELECT id_entreprise FROM acteurs WHERE id_acteur = ?))
          FROM role_permissions rp
          JOIN modules m ON rp.id_module = m.id_module
          WHERE rp.id_role = ?
        `, [id, id, id_role]);
      }
      
      // R√©cup√©rer l'acteur mis √† jour
      const [updatedActeurs] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_acteur = ?
      `, [id]);
      
      res.status(200).json(updatedActeurs[0]);
    } catch (error) {
      console.error('Erreur lors de la mise √† jour de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la mise √† jour de l\'acteur' });
    }
  }
);

// DELETE supprimer un acteur (avec validation des permissions)
router.delete('/:id', 
  authenticateToken, 
  checkPermission('USERS', 'supprimer'),
  async (req, res) => {
    try {
      const { id } = req.params;
      
      // V√©rifier que l'acteur existe et appartient √† la bonne entreprise
      let checkQuery = 'SELECT * FROM acteurs WHERE id_acteur = ?';
      let checkParams = [id];
      
      if (!req.user.hasGlobalAccess && req.user.id_entreprise) {
        checkQuery += ' AND id_entreprise = ?';
        checkParams.push(req.user.id_entreprise);
      }
      
      const [acteurs] = await pool.query(checkQuery, checkParams);
      
      if (acteurs.length === 0) {
        return res.status(404).json({ message: 'Acteur non trouv√© ou acc√®s non autoris√©' });
      }
      
      // Emp√™cher la suppression de son propre compte
      if (id === req.user.id_acteur) {
        return res.status(400).json({ message: 'Vous ne pouvez pas supprimer votre propre compte' });
      }
      
      await pool.query('DELETE FROM acteurs WHERE id_acteur = ?', [id]);
      
      res.status(200).json({ message: 'Acteur supprim√© avec succ√®s' });
    } catch (error) {
      console.error('Erreur lors de la suppression de l\'acteur:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la suppression de l\'acteur' });
    }
  }
);

// GET acteurs par entreprise
router.get('/entreprise/:entrepriseId', 
  authenticateToken, 
  checkPermission('USERS', 'voir'),
  async (req, res) => {
    try {
      const { entrepriseId } = req.params;
      
      // V√©rifier l'acc√®s √† cette entreprise
      if (!req.user.hasGlobalAccess && entrepriseId !== req.user.id_entreprise) {
        return res.status(403).json({ message: 'Acc√®s non autoris√© √† cette entreprise' });
      }
      
      const [acteurs] = await pool.query(`
        SELECT a.*, r.nom_role, r.niveau_acces, e.nom_entreprise
        FROM acteurs a
        JOIN roles r ON a.id_role = r.id_role
        LEFT JOIN entreprises e ON a.id_entreprise = e.id_entreprise
        WHERE a.id_entreprise = ?
        ORDER BY a.nom_prenom
      `, [entrepriseId]);
      
      res.status(200).json(acteurs);
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des acteurs par entreprise:', error);
      res.status(500).json({ message: 'Erreur serveur lors de la r√©cup√©ration des acteurs' });
    }
  }
);

// GET /api/acteurs/entreprise/:enterpriseId/by-role - R√©cup√©rer les acteurs par r√¥le
router.get('/entreprise/:enterpriseId/by-role', async (req, res) => {
  try {
    const { enterpriseId } = req.params;
    const { role } = req.query;
    
    let query = `
      SELECT a.*, r.nom_role, r.niveau_acces
      FROM acteurs a
      JOIN roles r ON a.id_role = r.id_role
      WHERE a.id_entreprise = ? AND a.is_active = 1
    `;
    
    let params = [enterpriseId];
    
    if (role) {
      query += ' AND r.nom_role = ?';
      params.push(role);
    }
    
    query += ' ORDER BY r.nom_role, a.nom_prenom';
    
    const [acteurs] = await pool.query(query, params);
    
    // Grouper par r√¥le pour une r√©ponse structur√©e
    const acteursParRole = acteurs.reduce((acc, acteur) => {
      const roleName = acteur.nom_role;
      if (!acc[roleName]) {
        acc[roleName] = [];
      }
      acc[roleName].push(acteur);
      return acc;
    }, {});
    
    res.json({
      entreprise_id: enterpriseId,
      acteurs_par_role: acteursParRole,
      total: acteurs.length
    });
    
  } catch (error) {
    logger.error('Erreur r√©cup√©ration acteurs par r√¥le:', error);
    res.status(500).json({
      message: 'Erreur serveur lors de la r√©cup√©ration des acteurs'
    });
  }
});


// POST /api/acteurs/intervenant - Cr√©er un intervenant pour une entreprise
router.post('/intervenant', [
  body('enterpriseId').isUUID().withMessage('ID entreprise invalide'),
  body('nom_prenom').isLength({ min: 2 }).withMessage('Nom et pr√©nom requis'),
  body('email').isEmail().withMessage('Email invalide'),
  body('fonction').isLength({ min: 1 }).withMessage('Fonction requise'),
  body('mot_de_passe').optional().isLength({ min: 8 }).withMessage('Mot de passe trop court (minimum 8 caract√®res)')
], async (req, res) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      await connection.rollback();
      return res.status(400).json({
        message: 'Donn√©es de validation invalides',
        errors: errors.array()
      });
    }
    
    const {
      enterpriseId,
      nom_prenom,
      email,
      fonction,
      mot_de_passe = null
    } = req.body;
    
    logger.info('üë• Cr√©ation intervenant:', { nom_prenom, email, entreprise: enterpriseId });
    
    // 1. V√©rifier que l'entreprise existe
    const [enterprises] = await connection.query(
      'SELECT nom_entreprise FROM entreprises WHERE id_entreprise = ?',
      [enterpriseId]
    );
    
    if (enterprises.length === 0) {
      await connection.rollback();
      return res.status(404).json({
        message: 'Entreprise non trouv√©e'
      });
    }
    
    const nomEntreprise = enterprises[0].nom_entreprise;
    
    // 2. V√©rifier que l'email n'existe pas d√©j√†
    const [existingActor] = await connection.query(
      'SELECT id_acteur FROM acteurs WHERE email = ?',
      [email]
    );
    
    if (existingActor.length > 0) {
      await connection.rollback();
      return res.status(400).json({
        message: 'Un utilisateur avec cet email existe d√©j√†'
      });
    }
    
    // 3. Obtenir le r√¥le Intervenant
    const [intervenantRoles] = await connection.query(
      'SELECT id_role FROM roles WHERE nom_role = ?',
      ['Intervenant']
    );
    
    if (intervenantRoles.length === 0) {
      // Cr√©er le r√¥le Intervenant s'il n'existe pas
      const roleId = uuidv4();
      await connection.query(`
        INSERT INTO roles (
          id_role, nom_role, description, niveau_acces
        ) VALUES (?, ?, ?, ?)
      `, [
        roleId,
        'Intervenant',
        'Intervenant dans l\'√©valuation de maturit√© - Participant aux questionnaires',
        'ENTREPRISE'
      ]);
      
      logger.info('R√¥le Intervenant cr√©√© automatiquement:', roleId);
      intervenantRoleId = roleId;
    } else {
      intervenantRoleId = intervenantRoles[0].id_role;
    }
    
    // 4. Cr√©er l'acteur intervenant
    const id_acteur = uuidv4();
    const now = new Date();
    let hashedPassword = null;
    
    if (mot_de_passe) {
      hashedPassword = await bcrypt.hash(mot_de_passe, 12);
    }
    
    await connection.query(`
      INSERT INTO acteurs (
        id_acteur, nom_prenom, email, mot_de_passe, organisation,
        id_entreprise, id_role, anciennete_role, is_active,
        date_creation, date_modification
      ) VALUES (?, ?, ?, ?, ?, ?, ?, 0, 1, ?, ?)
    `, [
      id_acteur, nom_prenom, email, hashedPassword,
      nomEntreprise, enterpriseId, intervenantRoleId, now, now
    ]);
    
    logger.info('‚úÖ Intervenant cr√©√©:', { id_acteur, nom_prenom, email });
    
    // 5. Cr√©er les permissions par d√©faut pour l'intervenant
    await createDefaultPermissions(connection, id_acteur, intervenantRoleId, enterpriseId);
    
    // 6. Commit transaction
    await connection.commit();
    
    // 7. R√©cup√©rer les donn√©es compl√®tes de l'intervenant cr√©√©
    const [actorData] = await connection.query(`
      SELECT a.*, r.nom_role, e.nom_entreprise
      FROM acteurs a
      JOIN roles r ON a.id_role = r.id_role
      JOIN entreprises e ON a.id_entreprise = e.id_entreprise
      WHERE a.id_acteur = ?
    `, [id_acteur]);
    
    logger.info('üéâ Intervenant cr√©√© avec succ√®s');
    
    res.status(201).json({
      message: 'Intervenant cr√©√© avec succ√®s',
      acteur: {
        id_acteur: actorData[0].id_acteur,
        nom_prenom: actorData[0].nom_prenom,
        email: actorData[0].email,
        fonction: fonction,
        role: actorData[0].nom_role,
        id_entreprise: actorData[0].id_entreprise,
        nom_entreprise: actorData[0].nom_entreprise,
        has_password: !!hashedPassword
      }
    });
    
  } catch (error) {
    await connection.rollback();
    logger.error('‚ùå Erreur cr√©ation intervenant:', error);
    res.status(500).json({
      message: 'Erreur serveur lors de la cr√©ation de l\'intervenant',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  } finally {
    connection.release();
  }
});

// Helper function pour les permissions (√† ajouter si pas d√©j√† pr√©sente)
const createDefaultPermissions = async (connection, actorId, roleId, enterpriseId) => {
  try {
    // R√©cup√©rer le nom du r√¥le
    const [roleData] = await connection.query(
      'SELECT nom_role FROM roles WHERE id_role = ?',
      [roleId]
    );
    
    if (roleData.length === 0) {
      throw new Error('R√¥le non trouv√©');
    }
    
    const roleName = roleData[0].nom_role;
    
    // R√©cup√©rer tous les modules actifs
    const [modules] = await connection.query(
      'SELECT id_module, nom_module FROM modules WHERE actif = TRUE'
    );
    
    // Permissions par d√©faut selon le r√¥le
    const permissions = {
      'Manager': {
        default: {
          peut_voir: true,
          peut_editer: true,
          peut_supprimer: false,
          peut_administrer: true
        },
        specific: {
          'USERS': { peut_supprimer: true },
          'EVALUATIONS': { peut_supprimer: true },
          'RAPPORTS': { peut_administrer: true }
        }
      },
      'Intervenant': {
        default: {
          peut_voir: true,
          peut_editer: false,
          peut_supprimer: false,
          peut_administrer: false
        },
        specific: {
          'QUESTIONNAIRES': { peut_editer: true },
          'EVALUATIONS': { peut_editer: true },
          'PROFIL': { peut_editer: true }
        }
      }
    };
    
    const rolePermissions = permissions[roleName] || permissions['Intervenant'];
    
    // Cr√©er les permissions pour chaque module
    for (const module of modules) {
      const modulePermissions = {
        ...rolePermissions.default,
        ...(rolePermissions.specific[module.nom_module] || {})
      };
      
      const permissionId = uuidv4();
      await connection.query(`
        INSERT INTO permissions (
          id_permission, id_acteur, id_module, type_ressource,
          peut_voir, peut_editer, peut_supprimer, peut_administrer,
          conditions, date_creation
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
      `, [
        permissionId,
        actorId,
        module.id_module,
        'GENERAL',
        modulePermissions.peut_voir,
        modulePermissions.peut_editer,
        modulePermissions.peut_supprimer,
        modulePermissions.peut_administrer,
        JSON.stringify({ entreprise_id: enterpriseId })
      ]);
    }
    
    logger.info(`Permissions ${roleName} cr√©√©es pour l'acteur ${actorId}`);
    
  } catch (error) {
    logger.warn('Erreur lors de la cr√©ation des permissions (non bloquant):', error.message);
  }
};

module.exports = router;